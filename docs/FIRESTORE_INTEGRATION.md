# Firebase Firestore Integration Technical Documentation

## 1. Overview

Firebase Cloud Firestore is integrated as a **server-side complement to PostgreSQL (Neon)** in the IPX/StoryPix Market project. It provides:

- **Distributed, real-time database** for user profiles, images, stories, and metadata
- **Automatic synchronization** with Vertex AI analysis results
- **Graceful fallback** when PostgreSQL is unavailable (development mode)
- **Zero impact on UI/UX** - all operations are server-side and non-blocking
- **Production-ready** with proper error handling and data consistency

### Why Firestore?

1. **Global Scale**: Firestore automatically replicates data across Google Cloud regions, enabling low-latency access worldwide
2. **Real-time Sync**: Live data updates for user interactions and AI analysis progress
3. **NoSQL Flexibility**: JSON-like document structure matches our complex, evolving data types (AI stories, tags, metadata)
4. **Seamless Integration**: Firebase SDKs handle authentication, permissions, and data validation
5. **Development-Friendly**: Works alongside PostgreSQL without conflicts or data duplication

---

## 2. Architecture

### Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                     Dataset Upload                              │
└────────────────┬────────────────────────────────────────────────┘
                 │
                 ▼
        ┌────────────────┐
        │  Save to SQL   │  (Neon PostgreSQL)
        │  (structured)  │  Primary transactional store
        └────────┬───────┘
                 │
         ┌───────┴───────┐
         │               │
         ▼               ▼
    ┌─────────┐   ┌──────────────┐
    │ Firestore  │   │ Vertex AI  │
    │ (user     │   │ Analysis   │
    │  records) │   │            │
    └─────────┘   └──────┬───────┘
                         │
                         ▼
                  ┌──────────────┐
                  │  Firestore   │
                  │  metadata    │
                  │  (stories,   │
                  │   tags,AI    │
                  │   results)   │
                  └──────────────┘
```

### Component Architecture

```
lib/firebase.ts
  ├─ initializeFirebase()           Firebase app initialization (singleton)
  ├─ getFirestoreInstance()         Get Firestore instance with fallback
  └─ Configuration validation       Checks for required env variables

lib/firestore.ts
  ├─ User operations
  │   ├─ createOrUpdateUser()       Upsert user profiles
  │   └─ getUserRecord()            Fetch user data
  ├─ Image operations
  │   ├─ saveImageRecord()          Store uploaded image metadata
  │   └─ getImagesByItemId()        Query images by dataset/model
  ├─ Story operations
  │   ├─ saveStoryRecord()          Store cinematic stories
  │   └─ getStoriesByItemId()       Query stories
  ├─ Metadata operations
  │   ├─ saveMetadata()             Store tags, captions, safety status
  │   └─ getMetadata()              Fetch item metadata
  └─ Vertex AI integration
      └─ updateVertexAiAnalysis()   Update AI analysis results

app/api/datasets/route.ts
  ├─ GET: Fetch datasets from SQL
  └─ POST: Create dataset
      ├─ Save to SQL (primary)
      ├─ Fire-and-forget: Save user to Firestore
      ├─ Fire-and-forget: Save image record
      ├─ Fire-and-forget: Save metadata
      └─ Fire-and-forget: Queue Vertex AI analysis
```

---

## 3. Data Schema & Collections

### Firestore Collections

#### `users` Collection
Stores user profile information.

```json
{
  "id": "0x1234...abcd",
  "displayName": "Alice Data",
  "wallet": "0x1234...abcd",
  "bio": "Data scientist & AI enthusiast",
  "avatar": "https://ipfs.io/...",
  "createdAt": "Timestamp(2024, 1, 15, 10, 30, 0)",
  "updatedAt": "Timestamp(2024, 1, 15, 10, 30, 0)"
}
```

**Purpose**: Replicate user profiles for cross-region queries and real-time updates.

#### `images` Collection
Tracks uploaded preview images and their metadata.

```json
{
  "id": "dataset_42_preview",
  "url": "https://ipfs.io/QmXxxx",
  "uploadTimestamp": "Timestamp(2024, 1, 15, 10, 30, 0)",
  "itemId": 42,
  "itemType": "dataset",
  "ownerWallet": "0x1234...abcd"
}
```

**Purpose**: Maintain audit trail of uploaded images for forensics and recovery.

#### `stories` Collection
Stores cinematic narratives generated by Vertex AI.

```json
{
  "id": "dataset_42_story_v1",
  "userStory": "Optional user-written narrative",
  "aiStory": "In the data realm, patterns emerge like stars...",
  "itemId": 42,
  "itemType": "dataset",
  "createdAt": "Timestamp(2024, 1, 15, 10, 30, 0)"
}
```

**Purpose**: Store multiple story versions and enable user-AI collaboration.

#### `metadata` Collection
Aggregates AI analysis results and item metadata.

```json
{
  "itemId": 42,
  "itemType": "dataset",
  "tags": ["climate", "timeseries", "ML-ready"],
  "caption": "Historical temperature records (1980-2024)",
  "safetyStatus": "approved",
  "vertexAiStory": "Cinematic story from Vertex AI Vision",
  "vertexAiCaption": "Enhanced caption from AI analysis",
  "vertexAiTags": ["environmental", "scientific", "prediction"],
  "vertexAiConfidence": 0.92,
  "updatedAt": "Timestamp(2024, 1, 15, 10, 30, 0)"
}
```

**Purpose**: Single source of truth for enriched metadata without cluttering PostgreSQL.

---

## 4. API Integration Points

### Dataset Upload Flow

```typescript
// app/api/datasets/route.ts - POST handler

// 1. Validate input & save to PostgreSQL (required)
const dataset = await sql`
  INSERT INTO datasets (...) VALUES (...) RETURNING *
`

// 2. Fire-and-forget: Save user profile to Firestore
createOrUpdateUser(ownerWallet, {
  id: ownerWallet,
  wallet: ownerWallet,
}).catch((error) => console.error(error))

// 3. Fire-and-forget: Save image record
saveImageRecord({
  id: `dataset_${dataset.id}_preview`,
  url: previewUrl,
  uploadTimestamp: Timestamp.now(),
  itemId: dataset.id,
  itemType: "dataset",
  ownerWallet,
}).catch((error) => console.error(error))

// 4. Fire-and-forget: Queue Vertex AI analysis
fetch("/api/analyze/image", {
  method: "POST",
  body: JSON.stringify({ imageUrl, itemId: dataset.id, itemType: "dataset" }),
}).catch((error) => console.error(error))
```

**Key Design Principle**: All Firestore operations are **non-blocking**. If Firestore fails, the database insert succeeds anyway.

### Vertex AI → Firestore Update Flow

```typescript
// app/api/analyze/image/route.ts - POST handler

// 1. Call Vertex AI API
const analysis = await analyzeImage(imageUrl)

// 2. Update Firestore metadata with results
await updateVertexAiAnalysis(itemId, itemType, {
  story: analysis.cinemaStory,
  caption: analysis.enhancedCaption,
  tags: analysis.semanticTags,
  confidence: analysis.confidence,
})

// 3. PostgreSQL is updated separately (if needed)
// This allows each system to be independent
```

---

## 5. Configuration & Setup

### Required Environment Variables

```env
# Firebase Project Configuration
FIREBASE_API_KEY=AIzaSyD...                    # Firebase Console > Project Settings
FIREBASE_AUTH_DOMAIN=storypix-market.firebaseapp.com
FIREBASE_PROJECT_ID=storypix-market-<uuid>
FIREBASE_STORAGE_BUCKET=storypix-market.appspot.com
FIREBASE_MESSAGING_SENDER_ID=123456789
FIREBASE_APP_ID=1:123456789:web:abc...
```

### How to Obtain Credentials

1. Go to [Firebase Console](https://console.firebase.google.com/)
2. Select or create a Firestore project
3. Navigate to **Project Settings** > **Your Apps** > **Web App**
4. Copy the config object values to your `.env.local`
5. In Firestore console, create collections: `users`, `images`, `stories`, `metadata`

### Graceful Degradation

If Firebase is not configured:
- All Firestore operations silently fail with console warnings
- PostgreSQL operations continue normally
- No user-facing errors or downtime

```typescript
if (!config.projectId) {
  console.warn("[v0] Firebase not configured - Firestore operations will be skipped")
  return null as any // Graceful fallback
}
```

---

## 6. Usage Examples

### Create/Update User

```typescript
import { createOrUpdateUser } from "@/lib/firestore"

await createOrUpdateUser("0x1234...abcd", {
  id: "0x1234...abcd",
  displayName: "Alice Data",
  wallet: "0x1234...abcd",
  bio: "Data scientist",
})
```

### Save Image Record

```typescript
import { saveImageRecord } from "@/lib/firestore"
import { Timestamp } from "firebase/firestore"

await saveImageRecord({
  id: "dataset_42_preview",
  url: "https://ipfs.io/...",
  uploadTimestamp: Timestamp.now(),
  itemId: 42,
  itemType: "dataset",
  ownerWallet: "0x1234...abcd",
})
```

### Query Stories by Item

```typescript
import { getStoriesByItemId } from "@/lib/firestore"

const stories = await getStoriesByItemId(42, "dataset")
// Returns array of StoryRecord objects
```

### Update Vertex AI Results

```typescript
import { updateVertexAiAnalysis } from "@/lib/firestore"

await updateVertexAiAnalysis(42, "dataset", {
  story: "Cinematic narrative from Vertex AI...",
  caption: "Enhanced caption from AI vision...",
  tags: ["ml-ready", "timeseries", "environmental"],
  confidence: 0.92,
})
```

---

## 7. Error Handling & Reliability

### Error Handling Strategy

All Firestore operations implement **graceful failure**:

```typescript
try {
  await saveMetadata(metadataData)
  console.log("[v0] Metadata saved successfully")
} catch (error) {
  console.warn("[v0] Failed to save metadata to Firestore:", error)
  // Don't throw - let operation continue
}
```

### Network Resilience

- **Firebase SDK**: Built-in offline persistence and automatic retries
- **Our Implementation**: Non-blocking fire-and-forget prevents bottlenecks
- **Monitoring**: Console logs track all operations for debugging

### Data Consistency

PostgreSQL is the **source of truth** for transactional data (orders, purchases, blockchain records). Firestore stores enrichment data (stories, AI results, user profiles) that can be regenerated if lost.

### Conflict Resolution

**No conflicts**: Each system handles separate data types:
- **PostgreSQL**: Transactions, orders, blockchain events, structured records
- **Firestore**: User profiles, stories, AI metadata, audit trails

---

## 8. Future Scalability

### Planned Enhancements

1. **Real-time Subscriptions**: WebSocket listeners for live story updates
   ```typescript
   onSnapshot(collection(db, "stories"), (snapshot) => {
     // Update UI with latest stories in real-time
   })
   ```

2. **Full-Text Search**: Firestore Vector Embeddings for semantic search
   ```typescript
   // Query stories similar to user input
   const similar = await semanticSearch("climate datasets", stories)
   ```

3. **Automated Backups**: Firebase Backup & Restore for disaster recovery

4. **Analytics Integration**: BigQuery export for data analysis pipeline
   ```sql
   SELECT * FROM `project.dataset.firestore_export`
   WHERE itemType = 'dataset' AND vertexAiConfidence > 0.9
   ```

5. **Multi-region Replication**: Distribute data across continents for faster access

### Performance Optimization

- **Indexing**: Composite indexes on frequently queried fields (itemId, itemType, createdAt)
- **Pagination**: Cursor-based pagination for large collections
- **Caching**: Redis layer for hot reads (user profiles, top stories)
- **Sharding**: Partition collections by timestamp for archive efficiency

---

## 9. Monitoring & Debugging

### Console Logs

All operations print `[v0]` prefixed logs:

```
[v0] Firebase Firestore initialized
[v0] User record saved to Firestore: 0x1234...abcd
[v0] Image record saved to Firestore: dataset_42_preview
[v0] Vertex AI analysis saved to Firestore: 42
[v0] Failed to save metadata to Firestore: [error details]
```

### Firebase Console Monitoring

1. Navigate to **Firestore** > **Data** to inspect collections
2. Check **Firestore** > **Indexes** for query optimization
3. View **Monitoring** > **Metrics** for read/write volume
4. Enable **Security Rules** auditing in **Firestore** > **Rules**

### Debugging Checklist

- [ ] Environment variables are set in `.env.local`
- [ ] Firebase project exists and Firestore is enabled
- [ ] Collections exist: `users`, `images`, `stories`, `metadata`
- [ ] Console logs show `[v0] Firebase Firestore initialized`
- [ ] No `PERMISSION_DENIED` errors in Firestore console
- [ ] Security rules allow write access (development mode is open, production needs rules)

---

## 10. Security & Best Practices

### Firestore Security Rules

For development (open access - **DO NOT USE IN PRODUCTION**):
```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      allow read, write: if true;  // ⚠️ DEVELOPMENT ONLY
    }
  }
}
```

For production (user-scoped access):
```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, write: if request.auth.uid == userId;
    }
    match /metadata/{docId} {
      allow read: if true;
      allow write: if request.auth != null;
    }
  }
}
```

### Best Practices

1. **Never log sensitive data**: Avoid logging wallet addresses in production
2. **Use service accounts**: Run server-side operations with restricted service accounts
3. **Enable encryption**: Use Firebase's built-in encryption at rest and in transit
4. **Implement audit trails**: Log all metadata changes for compliance
5. **Regular backups**: Export Firestore data weekly to Cloud Storage

---

## 11. Troubleshooting

### "Firebase not configured"

**Cause**: Environment variables are missing or incorrect.

**Solution**:
```bash
# Check environment variables
echo $FIREBASE_PROJECT_ID
echo $FIREBASE_API_KEY

# Should output non-empty values
```

### "Permission denied" Errors

**Cause**: Firestore security rules don't allow the operation.

**Solution**: 
1. Go to **Firestore** > **Rules**
2. For development: Use test mode (open access)
3. For production: Implement proper auth-based rules

### Slow Write Performance

**Cause**: Network latency or quota limits.

**Solutions**:
- Batch operations: Write multiple documents in single transaction
- Use regional endpoints for faster writes
- Check quota in **Firebase** > **Usage** > **Database**

### Data Not Appearing in Firestore

**Cause**: Operations are fire-and-forget (non-blocking).

**Solution**: 
- Check PostgreSQL insert succeeded first
- Check browser console for error logs
- Verify Firestore collections exist
- Check Firebase security rules

---

## Conclusion

Firebase Firestore is a **powerful, scalable complement** to PostgreSQL that enables real-time features, global distribution, and flexible data modeling—all without compromising the reliability of our primary transactional database. The server-side-only integration ensures zero impact on UI/UX while providing a foundation for future AI-powered enhancements like real-time story streaming and semantic search.
